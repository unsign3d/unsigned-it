<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>microservices on Random thoughts and ideas</title><link>https://lucabruzzone.me/tags/microservices/</link><description>Recent content in microservices on Random thoughts and ideas</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>All content is under CC BY-SA license. Luca Bruzzone</copyright><lastBuildDate>Wed, 01 Jul 2020 12:44:00 +0000</lastBuildDate><atom:link href="https://lucabruzzone.me/tags/microservices/index.xml" rel="self" type="application/rss+xml"/><item><title>Communication between microservices</title><link>https://lucabruzzone.me/posts/communication-between-microservices/index.xml</link><pubDate>Wed, 01 Jul 2020 12:44:00 +0000</pubDate><guid>https://lucabruzzone.me/posts/communication-between-microservices/</guid><description>&lt;p>This article was written and published 2020–01–07 on my personal blog, this is a repost&lt;/p>
&lt;h1 id="the-problem">The problem&lt;/h1>
&lt;p>Let’s say that you’re developing a software in a monolithic approach and you need to create a new functionality. What you will probably do is to search or define a new “business identity” and from there create what you need. If you need to expose something, you will create appropriate APIs, and if you need something from somewhere else, you will just call that method on that class.&lt;/p>
&lt;p>When you’re switching to micro-services, or generally a distributed system, this could get a bit complicated because you will have bits of information everywhere and you will start to have complexity rising.&lt;/p>
&lt;h1 id="just-call-it-approach">“Just call it” approach&lt;/h1>
&lt;p>Let’s imagine that you have a main system and you want to create for now just a small micro-service that is offloading from the main server a small task that is heavy on load. Typical example of this, could be a PDF generation.&lt;/p>
&lt;p>The most cost effective solution probably here could be creating the PDF generation “as a service” with an HTTP API (you have a bunch of choice for the protocol to use, you have REST, [g]RPC, GraphQL and many others).&lt;/p>
&lt;p>If you’re using some server-less platform (like AWS Lambda), you may also have the SDK with method of communication already provided to you. In my experience, usually that is the most reliable method because it’s “optimized” by your vendor. Of course, if you’re not careful and you’re building your software entirely based on a 3rd party SDK and that changes, or you want to change vendor, this is usually a bad idea&lt;/p>
&lt;h1 id="in-a-more-familiar-manner">In a more familiar manner&lt;/h1>
&lt;p>You can think about this method as the traditional “service class” method, you’re delegating something to a class, and you are calling it. This just happens over the network&lt;/p>
&lt;h1 id="pros">Pros&lt;/h1>
&lt;ul>
&lt;li>This is probably the simplest method that you can implement, it’s very junior-friendly and you will not have to explain and/or maintain complex architecture&lt;/li>
&lt;li>It’s probably the method with the less moving parts (since you’re not relying on a 3rd service for maintaining the documentation)&lt;/li>
&lt;li>It’s kinda easy to debug, you can associate a “request id” to the entirety of the request and you can see the whole flow of the request from your customer to the server that presented a problem&lt;/li>
&lt;li>You can implement synchronous call to that server and make the client wait for that request (useful in some cases like payment or image manipulation)&lt;/li>
&lt;/ul>
&lt;h1 id="cons">Cons&lt;/h1>
&lt;ul>
&lt;li>You will need to maintain an API, with versioning&lt;/li>
&lt;li>You will have a strong coupling, since the caller will need to know the existence of the server and how to communicate with it.&lt;/li>
&lt;li>You will need to take into consideration network latency, downstream service being not ready or reliable and everything that comes with and external service, even if the service is internal&lt;/li>
&lt;/ul>
&lt;h1 id="message-driven-architecture">Message driven architecture&lt;/h1>
&lt;p>This is a huge class of possibilities, here I will just touch the basics and the pros/cons of this approach.&lt;/p>
&lt;p>I will create more articles about multiple possibilities of implementing this ideology.&lt;/p>
&lt;h1 id="change-in-perspective">Change in perspective&lt;/h1>
&lt;p>If you choose to approach this ideology, you will need to shift from the paradigm of A asking to B something, and maybe B to reply to a more inverse approach. If you have already worked with the observer pattern, this will be more natural.&lt;/p>
&lt;p>Let’s take the old example of the invoice PDF generation.&lt;/p>
&lt;p>In a traditional architecture you would have the main service creating the invoice and then asking a service to generate the PDF, when the PDF is created you will serve it in some way&lt;/p>
&lt;p>In a message oriented architecture you have multiple players.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>A producer&lt;/strong>: a software that create something and “announce it” to the public&lt;/li>
&lt;li>&lt;strong>A consumer&lt;/strong>: a software that get the “message” and consumes it&lt;/li>
&lt;li>&lt;strong>A communication middleware / messaging system&lt;/strong>: It could be a message queue (RabbitMQ / ZeroMQ), a distributed logging (Apache Kafka) or anything that you can imagine&lt;/li>
&lt;/ul>
&lt;p>In the case of the example we will have our main application that &lt;strong>temporarily&lt;/strong> acts as a producer and announces to the middleware that the invoice is complete. The pdf generator will listen for messages and will &lt;strong>temporarily&lt;/strong> act as a consumer, taking all the information that he needs from the PDF generation and maybe he can also act as a producer and announce to the ecosystem that the PDF is ready (e.g.. you can have another service down the line that will take the PDF and sends it via email)&lt;/p>
&lt;h1 id="pros-1">Pros&lt;/h1>
&lt;p>As you can imagine already you will have an &lt;strong>extreme decoupling&lt;/strong> between services, if you’re sending enough information to describe the business action, everyone will be able to work without knowing about the consumers internal. This is usually why when you will start to encounter this kind of architectures when the project is expanding and more developers are joining, this is a typical architecture that you put in place to get to team independency&lt;/p>
&lt;p>The log of the message could become a source to understand what is happening in your whole ecosystem, you can also take those data and create some analysis&lt;/p>
&lt;h1 id="cons-1">Cons&lt;/h1>
&lt;ul>
&lt;li>Your communication middleware will become quickly your bottleneck&lt;/li>
&lt;li>Usually you don’t have guaranteed orders on the events, so you will need to create your code to adjust for those situations&lt;/li>
&lt;li>Duplication of similar events&lt;/li>
&lt;li>Difficulty of handling failures (in some cases you may have data loss, in some systems, data loss is actually taken into consideration and the ecosystem is built around it)&lt;/li>
&lt;li>Depending on the complexity of the project you will be unable to understand the full picture of what it’s going on after an action (as soon as you will embrace it, this will not be a problem anymore)&lt;/li>
&lt;/ul>
&lt;h1 id="why-should-i-use-it-then-if-its-so-complicated">Why should I use it then if it’s so complicated&lt;/h1>
&lt;p>&lt;strong>tl;dr&lt;/strong> usually it grows better and gives way fewer problems than similar alternatives, most of the problems are already solved for you and there is enough literature to not being afraid&lt;/p>
&lt;p>&lt;strong>The long answer&lt;/strong>&lt;/p>
&lt;p>If you need to have synchronous replies, this method is not the go-to. Just find some method to communicate directly and use it.&lt;/p>
&lt;p>If you’re not in a rush and you can do stuff in a more asynchronous way you can have a lot more advantages with this approach. If you have already used the observer pattern you will be more appreciative of this.&lt;/p>
&lt;p>Let’s take an example of a payment, as soon as the payment is complete you want to do the following:&lt;/p>
&lt;ul>
&lt;li>create an invoice&lt;/li>
&lt;li>register somewhere that the user paid for accountancy&lt;/li>
&lt;li>unlock features / start the wearhouse procedure for shipment&lt;/li>
&lt;li>update the CRM system&lt;/li>
&lt;li>update other ERP systems&lt;/li>
&lt;li>update dashboards&lt;/li>
&lt;li>that thing that the other team is working on, but it’s a test, so it doesn’t really work that much&lt;/li>
&lt;li>yeah we wanted also to do some tests, does the team have capacity?&lt;/li>
&lt;/ul>
&lt;p>This list of things has a couple of interesting properties:&lt;/p>
&lt;ul>
&lt;li>everything can be done in parallel&lt;/li>
&lt;li>probably some of these points we don’t even want to know what is happening, and we would like to delegate it to other teams&lt;/li>
&lt;/ul>
&lt;p>As soon as you’re publishing in the event pipeline that the payment is complete, you don’t need to care anymore about anything else (if you’re not in charge of the other systems). Also, if you look at the quantity of stuff that you will need to do, you will see that if you parallelize it you may save a lot of time&lt;/p></description></item></channel></rss>